## es6
### 字面量的增强
+ ES6中对 对象字面量 进行了增强，称之为 Enhanced object literals(增强对象字面量)。
+ 字面量的增强主要包括下面几部分:
    - 属性的简写:Property Shorthand
    - 方法的简写:Method Shorthand
    - 计算属性名:Computed Property Names
### 解构Destructuring
+ ES6中新增了一个从数组或对象中方便获取数据的方法，称之为解构Destructuring。
+ 我们可以划分为:数组的解构和对象的解构。
+ 数组的解构:
    - 基本解构过程 
    - 顺序解构
    - 解构出数组
    - 默认值
+ 对象的解构:
    - 基本解构过程 
    - 任意顺序
    - 重命名
    - 默认值
### 解构的应用场景
+ 解构目前在开发中使用是非常多的:
    -  比如在开发中拿到一个变量时，自动对其进行解构使用;
    -  比如对函数的参数进行解构;
### let/const基本使用
+ 在ES5中我们声明变量都是使用的var关键字，从ES6开始新增了两个关键字可以声明变量:let、const
    - let、const在其他编程语言中都是有的，所以也并不是新鲜的关键字;
    -  但是let、const确确实实给JavaScript带来一些不一样的东西;
+ let关键字:
    - 从直观的角度来说，let和var是没有太大的区别的，都是用于声明一个变量
+ const关键字:
    - const关键字是constant的单词的缩写，表示常量、衡量的意思;
    - 它表示保存的数据一旦被赋值，就不能被修改;
    - 但是如果赋值的是引用类型，那么可以通过引用找到对应的对象，修改对象的内容;
+ 注意:另外let、const不允许重复声明变量;
+ let、const和var的另一个区别是作用域提升
    - var声明的变量存在作用域提示
    - 但是let声明的变量 在声明前之前访问会报错
    - 这些半年两会创建在包含他们的词法环境被实例化时，但是是不可以访问的，知道词法绑定值
    - (作用域提升:在声明变量的作用域中，如果这个变量可以在声明之前被访问，那么我们可以称之为作用域提升)
    - 所以let、const没有进行作用域提升，但是会在解析阶段被创建出来。
### let\const和window
+ 在全局通过var来声明一个变量，事实上会在window上添加一个属性 但是let、const是不会给window上添加任何属性的
+ 变量保存到VariableMap中
    - 也就是说我们声明的变量和环境记录是被添加到变量环境中的:
    - 但是标准有没有规定这个对象是window对象或者其他对象呢?
    - 其实并没有，那么JS引擎在解析的时候，其实会有自己的实现;
    - 比如v8中其实是通过VariableMap的一个hashmap来实现它们的存储的。
    - 那么window对象呢?而window对象是早期的GO对象，在最新的实现中其实是浏览器添加的全局对象，并且 一直保持了window和var之间值的相等性;
### 暂时性死区
+ 在ES6中，有一个概念称为暂时性死区
    - 它表达的意思是在一段代码中，如果使用let、const,在声明之前，变量是无法被访问的
    - 我们将这种现象称之为temporal dead zone(暂时性死区,TDZ)
### let、const、let的选择
+ 对于var的使用
    -  我们需要明白一个事实，var所表现出来的特殊性:比如作用域提升、window全局对象、没有块级作用域等都是一些 历史遗留问题;
    -  但是在实际工作中，我们可以使用最新的规范来编写，也就是不再使用var来定义变量了;
+ 对于let、const:
    - 对于let和const来说，是目前开发中推荐使用的;
    - 我们会优先推荐使用const，这样可以保证数据的安全性不会被随意的篡改;
    - 只有当我们明确知道一个变量后续会需要被重新赋值时，这个时候再使用let;
    - 这种在很多其他语言里面也都是一种约定俗成的规范，尽量我们也遵守这种规范;
### 模板字符串
+ 模板字符串还有另外一种用法:标签模板字符串(Tagged Template Literals)。
+ 如果我们使用标签模板字符串，并且在调用的时候插入其他的变量:
    - 模板字符串被拆分了
    - 第一个元素是数组，是被模块字符串拆分的字符串组合;
    - 后面的元素是一个个模块字符串传入的内容;
    - react (css in js) -> all in js(styled components)
### 函数的默认参数
+ 在ES6之前，我们编写的函数参数是没有默认值的，所以我们在编写函数时，如果有下面的需求:
    -  传入了参数，那么使用传入的参数;
    - 没有传入参数，那么使用一个默认值;
+ 默认值也可以和解构一起来使用:
+ 另外参数的默认值我们通常会将其放到最后
+ 另外默认值会改变函数的length的个数，默认值以及后面的参数都不计算在length之内了。
### 函数的剩余参数
+ ES6中引用了rest parameter，可以将不定数量的参数放入到一个数组中:
    - 如果最后一个参数是 ... 为前缀的，那么它会将剩余的参数放到该参数中，并且作为一个数组;
+ 那么剩余参数和arguments有什么区别呢?
    - 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参;
    - arguments对象不是一个真正的数组，而rest参数是一个真正的数组，可以进行数组的所有操作;
    -  arguments是早期的ECMAScript中为了方便去获取所有的参数提供的一个数据结构，而rest参数是ES6中提供 并且希望以此来替代arguments的;
    - 剩余参数必须放到最后一个位置，否则会报错
### 箭头函数补充
+ 箭头函数是没有显式原型的，所以不能作为构造函数，使用new来创建对象;
### 展开语法(Spread syntax)
+ 可以在函数调用\数组构造时，将数组表达式或者string在语法层面展开
+ 还可以在构造字面量对象时，将对象表达式按key-value的方式展开
+ 在构建对象字面时，可以可以使用
### Symbol的基本使用
-  在ES6之前，对象的属性名都是字符串形式，那么很容易造成属性名的冲突;
- 比如原来有一个对象，我们希望在其中添加一个新的属性和值，但是我们在不确定它原来内部有什么内容的情况下， 很容易造成冲突，从而覆盖掉它内部的某个属性;
- 比如我们前面在讲apply、call、bind实现时，我们有给其中添加一个fn属性，那么如果它内部原来已经有了fn属性了 呢?
+ Symbol就是为了解决上面的问题，用来生成一个独一无二的值。
    - Symbol值是通过Symbol函数来生成的，生成后可以作为属性名;
    - 也就是在ES6中，对象的属性名可以使用字符串，也可以使用Symbol值;
+ Symbol即使多次创建值，它们也是不同的:Symbol函数执行后每次创建出来的值都是独一无二的;
+ 我们也可以在创建Symbol值的时候传入一个描述description:这个是ES2019(ES10)新增的特性;
### set的基本使用
+ 在es6之前，我们存储数据的结构主要有两种:数组、对象
    - 在es6中新增了另外两种数据结构set、map以及他们的另外形式WeakMap、WeakSet
+ set的常见属性和方法
    - 属性:size=>返回Set中元素的个数
    - 方法:add=>添加元素
    - 方法:delete=>删除元素
    - 方法:clear=>清除所以元素
    - 方法:has=>查找元素是否存在
    - 方法:forEach=>与数组的forEach一致
    - 也可以使用for of遍历
### WeakSet的基本使用
+ 与set的区别
    - WeakSet只能存放对象类型
    - WeakSet对元素的引用是弱引用，如果没有其他对象对其进行引用，那么GC会回收该对象
    - weakSet没有clear方法且无法做遍历操作
### Map的基本使用
+ 另一个新增的数据结构是Map，用于存储映射关系
+ 事实上我们对象存储影视关系只能用字符串作为属性名
+ 某些情况我们可能希望通过其他类型作为key，比如对象，这个时候会自动将对象转成字符串来作为key
+ Map常见的属性:
    - size:返回Map中元素的个数;
+ Map常见的方法:
    - set(key, value):在Map中添加key、value，并且返回整个Map对象; p get(key):根据key获取Map中的value;
    - has(key):判断是否包括某一个key，返回Boolean类型;
    - delete(key):根据key删除一个键值对，返回Boolean类型;
    - clear():清空所有的元素;
    - forEach(callback, [, thisArg]):通过forEach遍历Map;
### WeakMap
+ 与Map一样是通过键值对形式存在
+ 与Map的区别在于:
    - 区别一:WeakMap的key只能使用对象，不接受其他类型的key
    - 区别二:WeakMap对对象是弱引用
