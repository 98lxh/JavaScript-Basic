## js原型链
+ 在实现继承之前，首先理解一个非常重要的概念:原型链.
  - 从一个对象上获取属性,如果在当前对象中没有获取到就会去它的原型上获取
### Object的原型
  - 事实上Object的原型就已经是顶层的原型了
  - 从Object直接创建出来的对象原型都是[Object:null prototype]{}
+ [Object:null prototype]{}的特殊点
  - 1.这个对象有原型属性，但是他的原型属性已经指向null了，也就是顶层原型
  - 2.这个对象上有很多默认的属性和方法(toString、valueOf)
### 实现继承的方式
+ 原型链继承(06_originalChainInheritance.js)
  - 原型链继承的弊端
    *  第一，我们通过直接打印对象是看不到这个属性的
    *  第二，这个属性会被多个对象共享，如果这个对象是一个引用类型，那么就会造成问题;
    *  第三，不能给Person传递参数，因为这个对象是一次性创建的(没办法定制化);
+ 借用构造函数继承(07_constructorStealing.js)
    - 为了解决原型链继承中存在的问题，开发人员提供了一种新的技术: constructor stealing
  + 借用继承的做法非常简单:在子类型构造函数的内部调用父类型构造函数.
    - 因为函数可以在任意的时刻被调用;
    - 因此通过apply()和call()方法也可以在新创建的对象上执行构造函数;
  + 借用构造函数也是有弊端的
    - 1.该方法实例出的对象可以拿到父类父属性值，父类原型对象中一旦存在父类自己定义的方法
+ 组合继承(09_inheritance.js)
  + 组合继承是结合前两重方式的一种继承
  + 组合继承的弊端
    - 1.组合继承最大的问题就是无论在什么情况下，都会调用两次父类构造函数
    - 2.会在父类原型上添加一些不需要的属性
+ 原型式继承(10_prototypeModeInheritance.js)
  + 原型式继承的弊端
    - 该方法继承的引用类型数据指向相同的内存，会互相影响
+ 寄生式继承(11_ParasiticInheritance.js)
  + 寄生式继承的思路是结合原型类继承和工厂模式的一种方式;
  + 即创建一个封装继承过程的函数, 该函数在内部以某种方式来增强对象，最后再将这个对象返回;
+ 寄生组合继承(12_parasiticCombination.js)
  + 在前面几种继承方式的优缺点基础上进行改造，得出了寄生组合式继承的继承方式，也是目前所以继承方式里面相对最优的继承方式 
